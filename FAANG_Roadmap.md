# üöÄ FAANG Interview Preparation Roadmap

## üìã T·ªïng Quan
Roadmap n√†y ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ chu·∫©n b·ªã cho c√°c v√≤ng ph·ªèng v·∫•n FAANG (Facebook/Meta, Amazon, Apple, Netflix, Google) trong v√≤ng 6-12 th√°ng.

## üéØ M·ª•c Ti√™u Ch√≠nh
- [ ] Th√†nh th·∫°o Data Structures & Algorithms
- [ ] Hi·ªÉu s√¢u System Design
- [ ] Ph√°t tri·ªÉn k·ªπ nƒÉng Behavioral Interview
- [ ] X√¢y d·ª±ng portfolio m·∫°nh m·∫Ω
- [ ] Networking v√† referral

---

## üìö Phase 1: Foundation Building (Th√°ng 1-3)

### üîπ Data Structures & Algorithms
**M·ª•c ti√™u:** N·∫Øm v·ªØng c√°c kh√°i ni·ªám c∆° b·∫£n

#### Week 1-2: Basic Data Structures
- [ ] **OOP Fundamentals** üèóÔ∏è
  - Encapsulation, Inheritance, Polymorphism, Abstraction
  - Design Patterns (Singleton, Factory, Observer, Strategy)
  - SOLID Principles
  - **Essential OOP Problems:**
    - [ ] Design Parking Lot (LC System Design)
    - [ ] Design LRU Cache (LC 146)
    - [ ] Design HashMap (LC 706)
    - [ ] Design Twitter (LC 355)
    - [ ] Design Snake Game (LC 353)
    - [ ] Design Tic-Tac-Toe (LC 348)
    - [ ] Design File System (LC 588)
    - [ ] Design In-Memory File System (LC 588)
  - **Practice:** Implement 5+ design patterns in Python

- [ ] **Array & String**
  - Two pointers technique
  - Sliding window
  - String manipulation
  - **Essential Problems:**
    - [ ] Two Sum (LC 1)
    - [ ] Best Time to Buy and Sell Stock (LC 121)
    - [ ] Contains Duplicate (LC 217)
    - [ ] Product of Array Except Self (LC 238)
    - [ ] Maximum Subarray (LC 53)
    - [ ] 3Sum (LC 15)
    - [ ] Container With Most Water (LC 11)
    - [ ] Longest Substring Without Repeating Characters (LC 3)
    - [ ] Group Anagrams (LC 49)
    - [ ] Valid Parentheses (LC 20)
    - [ ] Valid Anagram (LC 242)
    - [ ] Palindrome Number (LC 9)
    - [ ] Roman to Integer (LC 13)
    - [ ] Longest Palindromic Substring (LC 5)
    - [ ] Encode and Decode Strings (LC 271)
  - **Practice:** 20+ problems easy/medium

- [ ] **Linked List**
  - Single/Double linked list
  - Fast & slow pointers
  - Reverse operations
  - **Essential Problems:**
    - [ ] Reverse Linked List (LC 206)
    - [ ] Linked List Cycle (LC 141)
    - [ ] Merge Two Sorted Lists (LC 21)
    - [ ] Remove Nth Node From End (LC 19)
    - [ ] Reorder List (LC 143)
    - [ ] Merge k Sorted Lists (LC 23)
    - [ ] Add Two Numbers (LC 2)
    - [ ] Copy List with Random Pointer (LC 138)
    - [ ] Find the Duplicate Number (LC 287)
    - [ ] LRU Cache (LC 146)
  - **Practice:** 15+ problems

#### Week 3-4: Trees & Graphs
- [ ] **Binary Trees**
  - Traversal (inorder, preorder, postorder)
  - Binary Search Trees
  - Tree construction
  - **Essential Problems:**
    - [ ] Maximum Depth of Binary Tree (LC 104)
    - [ ] Same Tree (LC 100)
    - [ ] Invert Binary Tree (LC 226)
    - [ ] Binary Tree Level Order Traversal (LC 102)
    - [ ] Subtree of Another Tree (LC 572)
    - [ ] Lowest Common Ancestor of BST (LC 235)
    - [ ] Binary Tree Right Side View (LC 199)
    - [ ] Count Good Nodes in Binary Tree (LC 1448)
    - [ ] Validate Binary Search Tree (LC 98)
    - [ ] Kth Smallest Element in BST (LC 230)
    - [ ] Construct Binary Tree from Preorder and Inorder (LC 105)
    - [ ] Binary Tree Maximum Path Sum (LC 124)
    - [ ] Serialize and Deserialize Binary Tree (LC 297)
    - [ ] Word Search II (LC 212)
  - **Practice:** 20+ problems

- [ ] **Graphs**
  - DFS/BFS
  - Topological sort
  - Union Find
  - **Essential Problems:**
    - [ ] Number of Islands (LC 200)
    - [ ] Clone Graph (LC 133)
    - [ ] Pacific Atlantic Water Flow (LC 417)
    - [ ] Course Schedule (LC 207)
    - [ ] Number of Connected Components (LC 323)
    - [ ] Graph Valid Tree (LC 261)
    - [ ] Word Ladder (LC 127)
    - [ ] Alien Dictionary (LC 269)
    - [ ] Network Delay Time (LC 743)
    - [ ] Cheapest Flights Within K Stops (LC 787)
    - [ ] Union Find (Redundant Connection LC 684)
    - [ ] Minimum Spanning Tree (Min Cost to Connect Points LC 1584)
  - **Practice:** 15+ problems

#### Week 5-8: Core Algorithms
- [ ] **Sorting & Searching**
  - Merge sort, Quick sort
  - Binary search variations
  - **Practice:** 15 problems

- [ ] **Dynamic Programming**
  - 1D DP (Fibonacci, coin change)
  - 2D DP (grid problems)
  - **Practice:** 25 problems

- [ ] **Backtracking**
  - Combinations/Permutations
  - N-Queens, Sudoku
  - **Practice:** 15 problems

#### Week 9-12: Advanced Topics
- [ ] **Greedy Algorithms**
  - Interval problems
  - Huffman coding
  - **Essential Problems:**
    - [ ] Meeting Rooms (LC 252)
    - [ ] Meeting Rooms II (LC 253)
    - [ ] Non-overlapping Intervals (LC 435)
    - [ ] Merge Intervals (LC 56)
    - [ ] Insert Interval (LC 57)
    - [ ] Jump Game (LC 55)
    - [ ] Gas Station (LC 134)
  - **Practice:** 10+ problems

- [ ] **Advanced DP**
  - Longest subsequences
  - String DP
  - **Essential Problems:**
    - [ ] Longest Increasing Subsequence (LC 300)
    - [ ] Longest Common Subsequence (LC 1143)
    - [ ] Word Break (LC 139)
    - [ ] Coin Change (LC 322)
    - [ ] Maximum Product Subarray (LC 152)
    - [ ] House Robber (LC 198)
    - [ ] House Robber II (LC 213)
    - [ ] Decode Ways (LC 91)
    - [ ] Unique Paths (LC 62)
    - [ ] Jump Game II (LC 45)
    - [ ] Edit Distance (LC 72)
    - [ ] Regular Expression Matching (LC 10)
  - **Practice:** 20+ problems

- [ ] **Bit Manipulation**
  - XOR operations, bit masking
  - Binary representations
  - **Essential Problems:**
    - [ ] Single Number (LC 136)
    - [ ] Number of 1 Bits (LC 191)
    - [ ] Counting Bits (LC 338)
    - [ ] Reverse Bits (LC 190)
    - [ ] Missing Number (LC 268)
    - [ ] Sum of Two Integers (LC 371)
  - **Practice:** 10+ problems

- [ ] **Math & Number Theory**
  - Prime numbers, GCD/LCM
  - Modular arithmetic
  - **Essential Problems:**
    - [ ] Happy Number (LC 202)
    - [ ] Plus One (LC 66)
    - [ ] Pow(x, n) (LC 50)
    - [ ] Sqrt(x) (LC 69)
    - [ ] Excel Sheet Column Number (LC 171)
    - [ ] Factorial Trailing Zeroes (LC 172)
  - **Practice:** 10+ problems

- [ ] **Two Heaps Pattern**
  - Find median problems
  - **Essential Problems:**
    - [ ] Find Median from Data Stream (LC 295)
    - [ ] Sliding Window Median (LC 480)
    - [ ] IPO (LC 502)
  - **Practice:** 5+ problems

### üîπ Programming Languages
- [ ] **Python:** Master advanced features (decorators, generators, collections)
- [ ] **C++:** STL, memory management, performance optimization
- [ ] **Optional:** Java or JavaScript (t√πy theo c√¥ng ty target)

### üîπ Computer Science Fundamentals
- [ ] **Time & Space Complexity**
  - Big O notation
  - Amortized analysis
  
- [ ] **Operating Systems**
  - Processes vs Threads
  - Memory management
  - Synchronization

- [ ] **Database Basics**
  - SQL queries
  - ACID properties
  - Indexing

---

## üèóÔ∏è Phase 2: System Design Mastery (Th√°ng 4-6)

### üîπ System Design Fundamentals
#### Week 1-2: Core Concepts
- [ ] **Scalability Principles**
  - Horizontal vs Vertical scaling
  - Load balancing
  - Caching strategies

- [ ] **Database Design**
  - SQL vs NoSQL
  - Sharding
  - Replication

---

## üåê **Distributed Systems Fundamentals (D·ªÖ Hi·ªÉu)**

### **Distributed System L√† G√¨? ü§î**
**ƒê·ªãnh nghƒ©a ƒë∆°n gi·∫£n:** Nhi·ªÅu m√°y t√≠nh l√†m vi·ªác c√πng nhau nh∆∞ m·ªôt h·ªá th·ªëng duy nh·∫•t.

**V√≠ d·ª• th·ª±c t·∫ø:**
- **Netflix:** Video ƒë∆∞·ª£c l∆∞u ·ªü nhi·ªÅu servers kh√°c nhau tr√™n th·∫ø gi·ªõi
- **WhatsApp:** Tin nh·∫Øn c·ªßa b·∫°n ƒëi qua nhi·ªÅu servers ƒë·ªÉ ƒë·∫øn ng∆∞·ªùi nh·∫≠n
- **Google Search:** T√¨m ki·∫øm tr√™n h√†ng tri·ªáu servers ƒë·ªìng th·ªùi

### **T·∫°i Sao C·∫ßn Distributed Systems? üí°**

#### 1. **Scalability (Kh·∫£ nƒÉng m·ªü r·ªông)**
```
M·ªôt m√°y ch·ªß ƒë∆°n l·∫ª:
- Gi·ªõi h·∫°n: 1000 users/gi√¢y
- Khi c√≥ 10,000 users ‚Üí Crash! ‚ùå

Distributed system (10 servers):
- Capacity: 10,000 users/gi√¢y
- Khi c√≥ th√™m users ‚Üí Th√™m servers! ‚úÖ
```

#### 2. **Fault Tolerance (Ch·ªãu l·ªói)**
```
Single server:
Server down ‚Üí To√†n b·ªô app down ‚ùå

Distributed (3 servers):
Server 1 down ‚Üí Server 2 & 3 v·∫´n ho·∫°t ƒë·ªông ‚úÖ
```

#### 3. **Performance (Hi·ªáu su·∫•t)**
```
User ·ªü Vi·ªát Nam:
- Connect ƒë·∫øn server ·ªü M·ªπ: 300ms latency ‚ùå
- Connect ƒë·∫øn server ·ªü Singapore: 50ms latency ‚úÖ
```

---

### **Core Concepts (T·ª´ng B∆∞·ªõc) üìö**

#### **1. CAP Theorem (ƒê·ªãnh l√Ω quan tr·ªçng nh·∫•t)**

**CAP = Consistency + Availability + Partition Tolerance**

B·∫°n ch·ªâ c√≥ th·ªÉ ch·ªçn **2 trong 3**:

**C - Consistency (T√≠nh nh·∫•t qu√°n):**
```
V√≠ d·ª•: T√†i kho·∫£n ng√¢n h√†ng
User A: R√∫t $100 t·ª´ ATM 1
User B: R√∫t $100 t·ª´ ATM 2 c√πng l√∫c

Consistency ƒë·∫£m b·∫£o: Ch·ªâ 1 giao d·ªãch th√†nh c√¥ng
Kh√¥ng c√≥ consistency: C·∫£ 2 r√∫t ƒë∆∞·ª£c (s·ªë d∆∞ √¢m!) ‚ùå
```

**A - Availability (T√≠nh s·∫µn s√†ng):**
```
V√≠ d·ª•: Facebook Feed
Server 1 down? ‚Üí Server 2 v·∫´n tr·∫£ v·ªÅ feed
User lu√¥n th·∫•y content (c√≥ th·ªÉ h∆°i c≈©)
```

**P - Partition Tolerance (Ch·ªãu ph√¢n m·∫£nh m·∫°ng):**
```
V√≠ d·ª•: Network gi·ªØa 2 data centers b·ªã ƒë·ª©t
Server A (US) kh√¥ng k·∫øt n·ªëi ƒë∆∞·ª£c Server B (EU)
H·ªá th·ªëng v·∫´n ph·∫£i ho·∫°t ƒë·ªông!
```

**Trade-offs trong th·ª±c t·∫ø:**

| System Type | Choice | Example |
|------------|--------|----------|
| **Banking** | CP (Consistency + Partition) | Better to be unavailable than show wrong balance |
| **Social Media** | AP (Availability + Partition) | Better to show slightly old content than be down |
| **Traditional DB** | CA (Consistency + Availability) | Works when network is perfect (not realistic) |

---

#### **2. Data Replication (Sao ch√©p d·ªØ li·ªáu)**

**T·∫°i sao c·∫ßn replication?**
- **Backup:** Server ch√≠nh ch·∫øt, d√πng b·∫£n sao
- **Performance:** ƒê·ªçc t·ª´ server g·∫ßn nh·∫•t
- **Load distribution:** Chia t·∫£i gi·ªØa nhi·ªÅu servers

**C√°c lo·∫°i Replication:**

##### **a) Master-Slave (Primary-Replica)**
```
          [Master DB]
         /     |     \
        /      |      \
   [Slave1] [Slave2] [Slave3]

Write ‚Üí Ch·ªâ v√†o Master
Read  ‚Üí T·ª´ b·∫•t k·ª≥ Slave n√†o

∆Øu ƒëi·ªÉm:
‚úÖ ƒê∆°n gi·∫£n
‚úÖ Read scalability t·ªët

Nh∆∞·ª£c ƒëi·ªÉm:
‚ùå Master down ‚Üí Kh√¥ng write ƒë∆∞·ª£c
‚ùå Data c√≥ th·ªÉ h∆°i c≈© ·ªü Slave (replication lag)
```

**V√≠ d·ª• th·ª±c t·∫ø:**
```python
# MySQL Master-Slave setup
class Database:
    def __init__(self):
        self.master = connect_to_master()
        self.slaves = [connect_to_slave(i) for i in range(3)]
    
    def write(self, query):
        return self.master.execute(query)  # Ch·ªâ write v√†o master
    
    def read(self, query):
        slave = random.choice(self.slaves)  # Random slave
        return slave.execute(query)
```

##### **b) Multi-Master (Active-Active)**
```
   [Master1] ‚Üê‚Üí [Master2]
       ‚Üï            ‚Üï
   [Slave1]    [Slave2]

Write ‚Üí V√†o b·∫•t k·ª≥ Master n√†o
Read  ‚Üí T·ª´ b·∫•t k·ª≥ node n√†o

∆Øu ƒëi·ªÉm:
‚úÖ High availability
‚úÖ Write scalability

Nh∆∞·ª£c ƒëi·ªÉm:
‚ùå Ph·ª©c t·∫°p (conflict resolution)
‚ùå Kh√≥ maintain consistency
```

---

#### **3. Sharding (Ph√¢n m·∫£nh d·ªØ li·ªáu)**

**Sharding = Chia data th√†nh nhi·ªÅu ph·∫ßn nh·ªè**

**T·∫°i sao c·∫ßn Sharding?**
```
Scenario: 1 billion users
Single database: Kh√¥ng ƒë·ªß RAM/Disk ‚ùå

Solution: Chia th√†nh 10 shards
M·ªói shard: 100 million users ‚úÖ
```

**C√°c chi·∫øn l∆∞·ª£c Sharding:**

##### **a) Hash-based Sharding**
```python
def get_shard(user_id, num_shards=10):
    shard_id = hash(user_id) % num_shards
    return shard_id

# V√≠ d·ª•:
user_123 ‚Üí hash(123) % 10 = 3 ‚Üí Shard 3
user_456 ‚Üí hash(456) % 10 = 6 ‚Üí Shard 6

∆Øu ƒëi·ªÉm:
‚úÖ Ph√¢n b·ªë ƒë·ªÅu
‚úÖ ƒê∆°n gi·∫£n

Nh∆∞·ª£c ƒëi·ªÉm:
‚ùå Kh√≥ re-shard (th√™m/b·ªõt shards)
‚ùå Kh√¥ng th·ªÉ range query d·ªÖ d√†ng
```

##### **b) Range-based Sharding**
```
Shard 1: user_id 1     - 1,000,000
Shard 2: user_id 1,000,001 - 2,000,000
Shard 3: user_id 2,000,001 - 3,000,000

∆Øu ƒëi·ªÉm:
‚úÖ Range queries d·ªÖ d√†ng
‚úÖ D·ªÖ th√™m shards

Nh∆∞·ª£c ƒëi·ªÉm:
‚ùå Hotspots (shard m·ªõi c√≥ nhi·ªÅu user active h∆°n)
```

##### **c) Geographic Sharding**
```
Shard US:   Users from United States
Shard EU:   Users from Europe
Shard ASIA: Users from Asia

∆Øu ƒëi·ªÉm:
‚úÖ Low latency (data g·∫ßn users)
‚úÖ Tu√¢n th·ªß lu·∫≠t (GDPR - data ·ªü EU)

Nh∆∞·ª£c ƒëi·ªÉm:
‚ùå Uneven distribution
```

---

#### **4. Consistency Models (C√°c m√¥ h√¨nh nh·∫•t qu√°n)**

##### **Strong Consistency**
```
Write completed ‚Üí T·∫•t c·∫£ reads th·∫•y data m·ªõi NGAY L·∫¨P T·ª®C

Timeline:
t=0: Write X=5 to Master
t=1: Master replicates to Slaves
t=2: Read from ANY slave ‚Üí Always returns X=5 ‚úÖ

V√≠ d·ª•: Banking, Inventory
Cost: Slower (ph·∫£i ƒë·ª£i replication)
```

##### **Eventual Consistency**
```
Write completed ‚Üí Reads SAU M·ªòT L√öC s·∫Ω th·∫•y data m·ªõi

Timeline:
t=0: Write X=5 to Master
t=1: Read from Slave1 ‚Üí Returns X=4 (old value)
t=5: Read from Slave1 ‚Üí Returns X=5 (updated)

V√≠ d·ª•: Social media feed, Comments
Benefit: Faster, more available
```

##### **Read-your-writes Consistency**
```
N·∫øu B·∫†N v·ª´a write ‚Üí B·∫†N ƒë·ªçc s·∫Ω th·∫•y data m·ªõi
Nh∆∞ng ng∆∞·ªùi kh√°c c√≥ th·ªÉ th·∫•y data c≈©

V√≠ d·ª•: Facebook post
- B·∫°n post status ‚Üí B·∫°n th·∫•y ngay ‚úÖ
- B·∫°n b√® c√≥ th·ªÉ th·∫•y sau v√†i gi√¢y
```

---

#### **5. Load Balancing (C√¢n b·∫±ng t·∫£i)**

**Load Balancer = "Traffic cop" c·ªßa h·ªá th·ªëng**

```
           [Load Balancer]
          /      |       \
         /       |        \
   [Server1] [Server2] [Server3]
```

**C√°c thu·∫≠t to√°n:**

##### **Round Robin**
```
Request 1 ‚Üí Server 1
Request 2 ‚Üí Server 2
Request 3 ‚Üí Server 3
Request 4 ‚Üí Server 1 (l·∫∑p l·∫°i)

‚úÖ ƒê∆°n gi·∫£n
‚ùå Kh√¥ng xem x√©t server load
```

##### **Least Connections**
```
Server 1: 5 active connections
Server 2: 3 active connections
Server 3: 8 active connections

New request ‚Üí Server 2 (√≠t connections nh·∫•t)

‚úÖ Better distribution
‚ùå Ph·ª©c t·∫°p h∆°n
```

##### **Weighted Round Robin**
```
Server 1 (powerful): Weight 5
Server 2 (medium):   Weight 3
Server 3 (weak):     Weight 2

Server 1 nh·∫≠n 50% traffic
Server 2 nh·∫≠n 30% traffic
Server 3 nh·∫≠n 20% traffic

‚úÖ T·∫≠n d·ª•ng hardware kh√°c nhau
```

---

#### **6. Caching Strategies (Chi·∫øn l∆∞·ª£c cache)**

**Cache = L∆∞u data ·ªü n∆°i truy c·∫≠p nhanh h∆°n**

##### **Cache-Aside (Lazy Loading)**
```python
def get_user(user_id):
    # 1. Check cache first
    user = cache.get(user_id)
    
    if user:
        return user  # Cache hit ‚úÖ
    
    # 2. Cache miss ‚Üí Query database
    user = database.get(user_id)
    
    # 3. Save to cache for next time
    cache.set(user_id, user, ttl=3600)
    
    return user

∆Øu ƒëi·ªÉm:
‚úÖ Ch·ªâ cache data th·ª±c s·ª± c·∫ßn
‚úÖ Resilient (cache down, v·∫´n ho·∫°t ƒë·ªông)

Nh∆∞·ª£c ƒëi·ªÉm:
‚ùå First request slow (cache miss)
‚ùå Stale data possible
```

##### **Write-Through Cache**
```python
def update_user(user_id, data):
    # 1. Write to cache FIRST
    cache.set(user_id, data)
    
    # 2. Write to database
    database.update(user_id, data)
    
    return True

∆Øu ƒëi·ªÉm:
‚úÖ Cache lu√¥n consistent v·ªõi DB
‚úÖ No cache miss for recently written data

Nh∆∞·ª£c ƒëi·ªÉm:
‚ùå Write latency cao h∆°n
‚ùå Waste n·∫øu data kh√¥ng ƒë∆∞·ª£c read
```

##### **Write-Behind (Write-Back) Cache**
```python
def update_user(user_id, data):
    # 1. Write to cache only
    cache.set(user_id, data)
    
    # 2. Async write to database (later)
    queue.add_task('write_to_db', user_id, data)
    
    return True  # Fast response!

∆Øu ƒëi·ªÉm:
‚úÖ Very fast writes
‚úÖ Batch writes to DB

Nh∆∞·ª£c ƒëi·ªÉm:
‚ùå Risk of data loss (cache crash before DB write)
```

---

#### **7. Message Queues (H√†ng ƒë·ª£i tin nh·∫Øn)**

**Use case:** X·ª≠ l√Ω async tasks

```
[API Server] ‚Üí [Queue] ‚Üí [Worker 1]
                    ‚Üì ‚Üí [Worker 2]
                    ‚Üì ‚Üí [Worker 3]
```

**V√≠ d·ª• th·ª±c t·∫ø:**
```python
# Scenario: User uploads video to YouTube

# Synchronous (BAD):
def upload_video(video_file):
    save_to_storage(video_file)       # 2 seconds
    generate_thumbnail(video_file)     # 5 seconds
    transcode_to_480p(video_file)      # 30 seconds
    transcode_to_720p(video_file)      # 60 seconds
    transcode_to_1080p(video_file)     # 90 seconds
    send_notification(user)            # 1 second
    
    return "Success"  # User waits 188 seconds! ‚ùå

# Asynchronous with Queue (GOOD):
def upload_video(video_file):
    save_to_storage(video_file)        # 2 seconds
    
    # Add tasks to queue
    queue.publish('thumbnail', video_file)
    queue.publish('transcode', video_file)
    queue.publish('notify', user)
    
    return "Processing..."  # User waits only 2 seconds! ‚úÖ

# Workers process in background
def thumbnail_worker():
    while True:
        task = queue.consume('thumbnail')
        generate_thumbnail(task.video_file)
```

**Popular Message Queues:**
- **RabbitMQ:** General purpose
- **Apache Kafka:** High throughput, streaming
- **Redis Queue:** Simple, fast
- **AWS SQS:** Managed service

---

### **Distributed System Patterns üéØ**

#### **1. Circuit Breaker Pattern**
```python
class CircuitBreaker:
    def __init__(self, failure_threshold=5):
        self.failure_count = 0
        self.failure_threshold = failure_threshold
        self.state = 'CLOSED'  # CLOSED, OPEN, HALF_OPEN
    
    def call_service(self, service_func):
        if self.state == 'OPEN':
            return "Service unavailable"  # Fail fast
        
        try:
            result = service_func()
            self.failure_count = 0  # Reset on success
            return result
        except Exception:
            self.failure_count += 1
            
            if self.failure_count >= self.failure_threshold:
                self.state = 'OPEN'  # Stop trying
            
            raise

# Usage
breaker = CircuitBreaker()
response = breaker.call_service(lambda: call_external_api())
```

#### **2. Saga Pattern (Distributed Transactions)**
```python
# Scenario: E-commerce order
# Need to: Reserve inventory, Charge card, Create shipment

class OrderSaga:
    def execute_order(self, order):
        # Step 1: Reserve inventory
        inventory_reserved = self.reserve_inventory(order)
        
        if not inventory_reserved:
            return "Failed"
        
        # Step 2: Charge payment
        payment_charged = self.charge_payment(order)
        
        if not payment_charged:
            self.rollback_inventory(order)  # Compensating transaction
            return "Failed"
        
        # Step 3: Create shipment
        shipment_created = self.create_shipment(order)
        
        if not shipment_created:
            self.rollback_payment(order)     # Compensate
            self.rollback_inventory(order)   # Compensate
            return "Failed"
        
        return "Success"
```

---

### **Practice Problems üìù**

#### **Scenario-based Questions:**

1. **Twitter Timeline Problem**
```
Y√™u c·∫ßu:
- 500M users
- Each user follows 200 people
- Generate timeline: latest 100 tweets from people you follow

C√¢u h·ªèi:
- Fan-out on write vs Fan-out on read?
- How to cache timelines?
- How to handle celebrities (1M+ followers)?
```

2. **Rate Limiter Design**
```
Y√™u c·∫ßu:
- Limit: 100 requests/minute per user
- Distributed system (multiple servers)

C√¢u h·ªèi:
- Fixed window vs Sliding window?
- Where to store counters? (Redis?)
- How to handle distributed counters?
```

3. **Distributed Lock**
```
Scenario: Only 1 server should process a job
Multiple servers competing for same job

C√¢u h·ªèi:
- How to implement distributed lock?
- What if lock holder crashes?
- Redlock algorithm?
```

#### Week 3-4: System Components
- [ ] **Distributed Systems**
  - CAP Theorem
  - Consistency models
  - Distributed consensus

- [ ] **Microservices Architecture**
  - Service communication
  - API design
  - Service discovery

#### Week 5-8: Classic System Design Problems
- [ ] **Design URL Shortener** (nh∆∞ bit.ly)
- [ ] **Design Chat System** (nh∆∞ WhatsApp)
- [ ] **Design Social Media Feed** (nh∆∞ Facebook)
- [ ] **Design Video Streaming** (nh∆∞ YouTube)
- [ ] **Design Search Engine** (nh∆∞ Google)
- [ ] **Design Ride Sharing** (nh∆∞ Uber)
- [ ] **Design E-commerce** (nh∆∞ Amazon)
- [ ] **Design Payment System** (nh∆∞ PayPal)

---

## üèóÔ∏è **System Design Interview Template (45 minutes)**

### **Step 1: Clarify Requirements (5 minutes)**
#### Functional Requirements
- [ ] What are the core features?
- [ ] Who are the users?
- [ ] What platforms (web, mobile, desktop)?
- [ ] Any specific use cases?

#### Non-Functional Requirements
- [ ] **Scale:** How many users? (DAU, MAU)
- [ ] **Performance:** Response time requirements?
- [ ] **Availability:** Uptime requirements (99.9%?)
- [ ] **Consistency:** Strong vs eventual consistency?
- [ ] **Security:** Authentication, authorization needs?

#### Out of Scope
- [ ] What features are we NOT building?
- [ ] Any assumptions we're making?

### **Step 2: Estimate Scale (5 minutes)**
#### Traffic Estimation
- [ ] **Daily Active Users (DAU):** e.g., 100M
- [ ] **Requests per second:** DAU * avg_requests_per_user / 86400
- [ ] **Peak traffic:** 3x average
- [ ] **Read vs Write ratio:** e.g., 100:1

#### Storage Estimation
- [ ] **Data per user:** e.g., 1KB per user
- [ ] **Total storage:** users * data_per_user
- [ ] **Growth rate:** 20% per year
- [ ] **Backup storage:** 3x primary storage

#### Bandwidth Estimation
- [ ] **Read QPS:** total_qps * read_ratio
- [ ] **Write QPS:** total_qps * write_ratio
- [ ] **Bandwidth:** QPS * avg_response_size

### **Step 3: High-Level Design (15 minutes)**
#### Major Components
- [ ] **Client Applications** (Web, Mobile, Desktop)
- [ ] **Load Balancer**
- [ ] **Web Servers** (API Gateway)
- [ ] **Application Servers**
- [ ] **Database Layer**
- [ ] **Cache Layer**
- [ ] **CDN** (for static content)
- [ ] **Message Queue** (for async processing)

#### API Design
```
# Example: URL Shortener
POST /api/v1/urls
  Request: {"original_url": "https://example.com"}
  Response: {"short_url": "https://bit.ly/abc123"}

GET /api/v1/urls/{short_code}
  Response: {"original_url": "https://example.com"}

DELETE /api/v1/urls/{short_code}
  Response: {"success": true}
```

#### Database Schema
```sql
-- Example: URL Shortener
CREATE TABLE urls (
  id BIGINT PRIMARY KEY,
  short_code VARCHAR(7) UNIQUE,
  original_url TEXT,
  created_at TIMESTAMP,
  expires_at TIMESTAMP,
  user_id BIGINT
);

CREATE INDEX idx_short_code ON urls(short_code);
CREATE INDEX idx_user_id ON urls(user_id);
```

### **Step 4: Detailed Design (15 minutes)**
#### Deep Dive Topics (Choose 2-3)
- [ ] **Database Design**
  - SQL vs NoSQL choice
  - Sharding strategy
  - Replication setup
  - ACID properties

- [ ] **Caching Strategy**
  - Cache-aside vs Write-through
  - Cache invalidation
  - Hot data identification
  - Cache warm-up

- [ ] **Load Balancing**
  - Round-robin vs Weighted
  - Health checks
  - Sticky sessions
  - Geographic routing

- [ ] **Microservices**
  - Service boundaries
  - Inter-service communication
  - Circuit breakers
  - Service discovery

- [ ] **Security**
  - Authentication (JWT, OAuth)
  - Authorization (RBAC)
  - Rate limiting
  - Input validation

#### Handle Bottlenecks
- [ ] **Database bottlenecks**
  - Read replicas
  - Horizontal sharding
  - Database federation

- [ ] **Application bottlenecks**
  - Horizontal scaling
  - Stateless design
  - Connection pooling

- [ ] **Network bottlenecks**
  - CDN for static content
  - Data compression
  - Keep-alive connections

### **Step 5: Scale & Monitor (5 minutes)**
#### Monitoring & Alerting
- [ ] **Application Metrics**
  - Response time, throughput
  - Error rates (4xx, 5xx)
  - Business metrics

- [ ] **Infrastructure Metrics**
  - CPU, memory, disk usage
  - Network bandwidth
  - Database performance

- [ ] **Alerting Strategy**
  - SLA-based alerts
  - Escalation policies
  - Incident response

#### Logging Strategy
- [ ] **Structured logging** (JSON format)
- [ ] **Log aggregation** (ELK stack)
- [ ] **Distributed tracing** (Jaeger, Zipkin)
- [ ] **Log retention** policies

---

## üéØ **System Design Case Studies (Complete)**

### 1. **Design URL Shortener (nh∆∞ Bit.ly)**
#### Requirements
- Shorten long URLs to 6-7 characters
- Redirect to original URL
- Custom aliases
- Analytics (click tracking)
- 100M URLs shortened daily

#### Key Components
- **Encoding Algorithm:** Base62 (a-z, A-Z, 0-9)
- **Database:** NoSQL for scale (Cassandra/DynamoDB)
- **Cache:** Redis for hot URLs
- **Analytics:** Kafka + Stream processing

### 2. **Design Chat System (nh∆∞ WhatsApp)**
#### Requirements
- 1-on-1 and group messaging
- Online/offline status
- Message delivery confirmation
- 1B daily active users
- 100B messages per day

#### Key Components
- **Real-time:** WebSocket connections
- **Message Queue:** Kafka for message delivery
- **Database:** Cassandra for message storage
- **Push Notifications:** FCM/APNs

### 3. **Design Social Media Feed (nh∆∞ Facebook)**
#### Requirements
- News feed generation
- Post creation/sharing
- Follow/friend system
- 2B daily active users
- 300M posts per day

#### Key Components
- **Feed Generation:** Pull vs Push model
- **Graph Database:** Neo4j for social graph
- **Content Storage:** S3 for media
- **ML Pipeline:** Feed ranking algorithm

### üîπ High-Level Design Skills
- [ ] **Architecture Patterns**
  - MVC, MVP, MVVM
  - Event-driven architecture
  - CQRS pattern

- [ ] **Performance Optimization**
  - CDN usage
  - Database optimization
  - Caching layers

---

## üíº Phase 3: Advanced Preparation (Th√°ng 7-9)

### üîπ Advanced Algorithms
- [ ] **Graph Algorithms**
  - Dijkstra's algorithm
  - Floyd-Warshall
  - Minimum spanning tree

- [ ] **Advanced Data Structures**
  - Trie
  - Segment tree
  - Heap variations

- [ ] **String Algorithms**
  - KMP algorithm
  - Rabin-Karp
  - Suffix arrays

### üîπ Company-Specific Preparation
#### Google
- [ ] Focus: Graph problems, system design scale
- [ ] Practice: Google-specific problems on Leetcode

#### Meta (Facebook)
- [ ] Focus: Dynamic programming, behavioral questions
- [ ] Practice: Meta-tagged problems

#### Amazon
- [ ] Focus: Coding + behavioral (Leadership Principles)
- [ ] Practice: Amazon-specific problems

#### Apple
- [ ] Focus: Low-level programming, iOS development
- [ ] Practice: C++ and system programming

#### Netflix
- [ ] Focus: System design, distributed systems
- [ ] Practice: Large-scale system problems

### üîπ Behavioral Interview Preparation
- [ ] **STAR Method** (Situation, Task, Action, Result)
- [ ] **Leadership Stories**
  - Times you led a project
  - Conflict resolution
  - Innovation examples

- [ ] **Technical Leadership**
  - Architecture decisions
  - Code reviews
  - Mentoring experiences

---

## üéØ Phase 4: Interview Practice (Th√°ng 10-12)

### üîπ Mock Interviews
- [ ] **Algorithm Interviews**
  - Practice 3x/week v·ªõi timer
  - Record yourself coding
  - Use Pramp, InterviewBit

- [ ] **System Design Interviews**
  - Practice 2x/week
  - Draw diagrams
  - Explain trade-offs

- [ ] **Behavioral Interviews**
  - Practice v·ªõi friends/mentors
  - Record and review

### üîπ Final Preparations
- [ ] **Resume Optimization**
  - Quantify achievements
  - Highlight relevant projects
  - ATS optimization

- [ ] **Portfolio Projects**
  - Build 2-3 impressive projects
  - Deploy to cloud (AWS/GCP)
  - Write detailed documentation

- [ ] **Networking**
  - LinkedIn optimization
  - Attend tech meetups
  - Connect with FAANG employees

---

## üìä Weekly Schedule Template

### Weekdays (Mon-Fri): 2-3 hours/day
- **Morning (1 hour):** Algorithm practice (2-3 problems)
- **Evening (1-2 hours):** System design study or behavioral prep

### Weekends: 4-6 hours/day
- **Saturday:** Mock interviews + project work
- **Sunday:** Review weak areas + system design practice

---

## üìÖ **Detailed Daily Practice Schedule**

### **Monday - Wednesday - Friday: Algorithm Focus**
#### Morning Routine (6:00-7:00 AM)
- [ ] **Warm-up (15 mins):** Review previous day's problems
- [ ] **Easy Problem (20 mins):** Build confidence
- [ ] **Medium Problem (25 mins):** Core skill building

#### Evening Session (8:00-9:30 PM)
- [ ] **Hard Problem (45 mins):** Challenge yourself
- [ ] **Review & Notes (30 mins):** Document patterns
- [ ] **Spaced Repetition (15 mins):** Anki flashcards

### **Tuesday - Thursday: System Design Focus**
#### Morning Routine (6:00-7:00 AM)
- [ ] **Reading (30 mins):** System design concepts
- [ ] **Flashcards (15 mins):** Review terminology
- [ ] **Quick Sketch (15 mins):** Practice diagramming

#### Evening Session (8:00-9:30 PM)
- [ ] **Design Case Study (60 mins):** Complete end-to-end design
- [ ] **Trade-offs Analysis (30 mins):** Document pros/cons

### **Saturday: Mock Interview Day**
#### Morning (9:00-12:00 PM)
- [ ] **Algorithm Mock (90 mins):** Timed coding session
- [ ] **Break (30 mins):** Rest and reflect

#### Afternoon (1:00-4:00 PM)
- [ ] **System Design Mock (60 mins):** Practice with timer
- [ ] **Behavioral Practice (60 mins):** STAR method stories
- [ ] **Project Work (60 mins):** Portfolio development

### **Sunday: Review & Planning**
#### Morning (9:00-12:00 PM)
- [ ] **Week Review (60 mins):** Analyze mistakes and patterns
- [ ] **Weak Areas Practice (120 mins):** Focus on problem areas

#### Afternoon (1:00-4:00 PM)
- [ ] **Next Week Planning (30 mins):** Set goals and schedule
- [ ] **Long-term Project (150 mins):** Work on portfolio projects

---

## ü§ñ **AI/ML Side Projects Portfolio (3-6 months)**

### **Phase 1: Foundation Projects (Month 1-2)**

#### Project 1: **Personal AI Assistant with RAG** ü§ñ
- **Tech Stack:** Python, LangChain, OpenAI API, Vector DB (Pinecone/Chroma)
- **Features:**
  - [ ] Document ingestion (PDF, TXT, web scraping)
  - [ ] Vector embeddings and similarity search
  - [ ] Chat interface with memory
  - [ ] Source citation and fact-checking
  - [ ] Web deployment (Streamlit/Gradio)
- **Learning Goals:** RAG architecture, embeddings, prompt engineering
- **GitHub:** Full documentation + demo video
- **Timeline:** 3-4 weeks

#### Project 2: **Computer Vision Image Classifier** üëÅÔ∏è
- **Tech Stack:** PyTorch/TensorFlow, OpenCV, FastAPI, Docker
- **Features:**
  - [ ] Custom dataset creation and labeling
  - [ ] Transfer learning (ResNet, EfficientNet)
  - [ ] Data augmentation pipeline
  - [ ] Model training and evaluation
  - [ ] REST API for inference
  - [ ] Real-time webcam classification
- **Learning Goals:** Deep learning, computer vision, model deployment
- **Dataset:** Custom or Kaggle competition
- **Timeline:** 3-4 weeks

### **Phase 2: Advanced Projects (Month 3-4)**

#### Project 3: **Real-time Recommendation System** üéØ
- **Tech Stack:** Python, Apache Kafka, Redis, PostgreSQL, MLflow
- **Features:**
  - [ ] Collaborative filtering + Content-based filtering
  - [ ] Real-time feature engineering
  - [ ] A/B testing framework
  - [ ] Model versioning and monitoring
  - [ ] Scalable inference pipeline
  - [ ] User interaction tracking
- **Learning Goals:** Recommendation algorithms, streaming, MLOps
- **Scale:** Handle 10K+ users simulation
- **Timeline:** 4-5 weeks

#### Project 4: **Natural Language Processing Pipeline** üìù
- **Tech Stack:** Transformers, spaCy, NLTK, Hugging Face, FastAPI
- **Features:**
  - [ ] Text preprocessing and cleaning
  - [ ] Named Entity Recognition (NER)
  - [ ] Sentiment analysis
  - [ ] Text summarization
  - [ ] Question-answering system
  - [ ] Multi-language support
- **Learning Goals:** NLP, transformers, text processing
- **Dataset:** News articles, reviews, or domain-specific data
- **Timeline:** 4 weeks

### **Phase 3: Production-Ready Projects (Month 5-6)**

#### Project 5: **MLOps End-to-End Platform** üöÄ
- **Tech Stack:** MLflow, Airflow, Docker, Kubernetes, AWS/GCP
- **Features:**
  - [ ] Automated data pipeline (ETL)
  - [ ] Model training orchestration
  - [ ] Hyperparameter tuning (Optuna/Ray Tune)
  - [ ] Model registry and versioning
  - [ ] A/B testing infrastructure
  - [ ] Monitoring and alerting
  - [ ] CI/CD for ML models
- **Learning Goals:** MLOps, DevOps, cloud deployment
- **Scale:** Production-grade infrastructure
- **Timeline:** 5-6 weeks

#### Project 6: **Generative AI Application** ‚ú®
- **Tech Stack:** OpenAI/Anthropic API, LangChain, Vector DB, React/Next.js
- **Features:**
  - [ ] Multi-modal AI (text, image, audio)
  - [ ] Custom fine-tuning (LoRA/QLoRA)
  - [ ] Prompt optimization and caching
  - [ ] User authentication and usage tracking
  - [ ] Payment integration (if applicable)
  - [ ] Production deployment
- **Learning Goals:** Generative AI, fine-tuning, product development
- **Examples:** Code generator, content writer, image editor
- **Timeline:** 4-5 weeks

---

## üåê **Distributed Systems Side Projects**

### **Project 7: Distributed Task Queue System** üîÑ
- **Tech Stack:** Python, Redis, Celery, RabbitMQ, Docker
- **Features:**
  - [ ] Task producer and consumer architecture
  - [ ] Priority queues (high, medium, low)
  - [ ] Retry mechanism with exponential backoff
  - [ ] Dead letter queue for failed tasks
  - [ ] Task monitoring dashboard
  - [ ] Distributed workers (scale horizontally)
  - [ ] Rate limiting per worker
- **Learning Goals:** Message queues, async processing, distributed workers
- **Real-world Example:** Background job processing nh∆∞ Sidekiq
- **Timeline:** 3 weeks

**Implementation Example:**
```python
# tasks.py
from celery import Celery

app = Celery('tasks', broker='redis://localhost:6379')

@app.task(bind=True, max_retries=3)
def process_video(self, video_id):
    try:
        # Simulate heavy processing
        generate_thumbnail(video_id)
        transcode_video(video_id)
        return f"Processed {video_id}"
    except Exception as exc:
        raise self.retry(exc=exc, countdown=60)  # Retry after 1 min

# producer.py
from tasks import process_video

# Add task to queue
process_video.delay(video_id=123)
```

---

### **Project 8: Distributed Cache System (Mini-Redis)** üíæ
- **Tech Stack:** Python/Go, TCP Sockets, Consistent Hashing
- **Features:**
  - [ ] In-memory key-value store
  - [ ] GET, SET, DELETE operations
  - [ ] TTL (Time-To-Live) expiration
  - [ ] LRU eviction policy
  - [ ] Consistent hashing for distributed nodes
  - [ ] Replication (master-slave)
  - [ ] Simple persistence (snapshots)
- **Learning Goals:** Caching, distributed hashing, replication
- **Real-world Example:** Simplified Redis/Memcached
- **Timeline:** 4 weeks

**Key Implementation:**
```python
import hashlib
import bisect

class ConsistentHashRing:
    def __init__(self, nodes, virtual_nodes=150):
        self.virtual_nodes = virtual_nodes
        self.ring = {}
        self.sorted_keys = []
        
        for node in nodes:
            self.add_node(node)
    
    def add_node(self, node):
        for i in range(self.virtual_nodes):
            virtual_key = f"{node}:{i}"
            hash_value = self._hash(virtual_key)
            self.ring[hash_value] = node
            bisect.insort(self.sorted_keys, hash_value)
    
    def get_node(self, key):
        if not self.ring:
            return None
        
        hash_value = self._hash(key)
        idx = bisect.bisect_right(self.sorted_keys, hash_value)
        
        if idx == len(self.sorted_keys):
            idx = 0
        
        return self.ring[self.sorted_keys[idx]]
    
    def _hash(self, key):
        return int(hashlib.md5(key.encode()).hexdigest(), 16)

# Usage
nodes = ['server1:6379', 'server2:6379', 'server3:6379']
hash_ring = ConsistentHashRing(nodes)

# Get which server to use for a key
server = hash_ring.get_node('user:123')  # ‚Üí server2:6379
```

---

### **Project 9: Distributed Rate Limiter** üö¶
- **Tech Stack:** Python, Redis, FastAPI, Docker
- **Features:**
  - [ ] Token bucket algorithm
  - [ ] Sliding window counter
  - [ ] Per-user rate limiting
  - [ ] Per-IP rate limiting
  - [ ] Distributed counter (Redis)
  - [ ] Real-time monitoring
  - [ ] Custom rate limit rules
- **Learning Goals:** Rate limiting algorithms, distributed counters
- **Real-world Example:** API gateway rate limiting
- **Timeline:** 2 weeks

**Implementation:**
```python
import time
import redis
from fastapi import FastAPI, Request, HTTPException

app = FastAPI()
redis_client = redis.Redis(host='localhost', port=6379)

class SlidingWindowRateLimiter:
    def __init__(self, max_requests=100, window_size=60):
        self.max_requests = max_requests
        self.window_size = window_size
    
    def is_allowed(self, user_id):
        now = time.time()
        window_start = now - self.window_size
        
        key = f"rate_limit:{user_id}"
        
        # Remove old entries
        redis_client.zremrangebyscore(key, 0, window_start)
        
        # Count requests in current window
        request_count = redis_client.zcard(key)
        
        if request_count < self.max_requests:
            # Add current request
            redis_client.zadd(key, {now: now})
            redis_client.expire(key, self.window_size)
            return True
        
        return False

rate_limiter = SlidingWindowRateLimiter(max_requests=10, window_size=60)

@app.get("/api/data")
async def get_data(request: Request):
    user_id = request.client.host
    
    if not rate_limiter.is_allowed(user_id):
        raise HTTPException(status_code=429, detail="Too many requests")
    
    return {"data": "Your data here"}
```

---

### **Project 10: Distributed Log Aggregator** üìä
- **Tech Stack:** Python, Kafka, Elasticsearch, Kibana, Docker
- **Features:**
  - [ ] Collect logs from multiple services
  - [ ] Real-time log streaming (Kafka)
  - [ ] Log parsing and indexing (Elasticsearch)
  - [ ] Search and visualization (Kibana)
  - [ ] Alert system for error patterns
  - [ ] Log retention policies
  - [ ] Distributed tracing correlation
- **Learning Goals:** Log aggregation, streaming, search indexing
- **Real-world Example:** ELK Stack, Splunk
- **Timeline:** 4 weeks

**Architecture:**
```
[Microservice 1] ‚îÄ‚îÄ‚îê
[Microservice 2] ‚îÄ‚îÄ‚îº‚îÄ‚îÄ> [Kafka] ‚îÄ‚îÄ> [Logstash] ‚îÄ‚îÄ> [Elasticsearch]
[Microservice 3] ‚îÄ‚îÄ‚îò                                      |
                                                           v
                                                      [Kibana]
```

---

### **Project 11: Distributed Key-Value Database** üóÑÔ∏è
- **Tech Stack:** Python/Go, gRPC, Raft Consensus, Docker
- **Features:**
  - [ ] Distributed consensus (Raft algorithm)
  - [ ] Leader election
  - [ ] Log replication
  - [ ] Fault tolerance (handle node failures)
  - [ ] Read/Write operations
  - [ ] Snapshot and log compaction
  - [ ] Cluster membership changes
- **Learning Goals:** Distributed consensus, fault tolerance, replication
- **Real-world Example:** etcd, Consul
- **Timeline:** 6 weeks (challenging!)

---

### **Project 12: Microservices E-commerce Platform** üõí
- **Tech Stack:** Python, FastAPI, PostgreSQL, Redis, Docker, Kubernetes
- **Microservices:**
  - [ ] **User Service:** Authentication, profiles
  - [ ] **Product Service:** Catalog, inventory
  - [ ] **Order Service:** Order processing
  - [ ] **Payment Service:** Payment gateway integration
  - [ ] **Notification Service:** Email, SMS
  - [ ] **API Gateway:** Single entry point
- **Features:**
  - [ ] Service discovery (Consul/etcd)
  - [ ] Inter-service communication (gRPC)
  - [ ] Distributed tracing (Jaeger)
  - [ ] Circuit breaker pattern
  - [ ] Saga pattern for distributed transactions
  - [ ] Event-driven architecture (Kafka)
- **Learning Goals:** Microservices, service mesh, orchestration
- **Timeline:** 8 weeks

**Service Communication Example:**
```python
# order_service.py
import grpc
from payment_service_pb2 import PaymentRequest
from payment_service_pb2_grpc import PaymentServiceStub

class OrderService:
    def create_order(self, order_data):
        # Step 1: Reserve inventory
        inventory_reserved = self.inventory_client.reserve(order_data)
        
        if not inventory_reserved:
            return {"status": "failed", "reason": "out of stock"}
        
        # Step 2: Process payment via gRPC
        with grpc.insecure_channel('payment-service:50051') as channel:
            stub = PaymentServiceStub(channel)
            
            payment_request = PaymentRequest(
                order_id=order_data['id'],
                amount=order_data['total'],
                user_id=order_data['user_id']
            )
            
            payment_response = stub.ProcessPayment(payment_request)
            
            if not payment_response.success:
                # Rollback inventory
                self.inventory_client.release(order_data)
                return {"status": "failed", "reason": "payment failed"}
        
        # Step 3: Publish event
        self.kafka_producer.send('order-created', order_data)
        
        return {"status": "success", "order_id": order_data['id']}
```

---

### **Bonus: Distributed System Tools to Learn** üõ†Ô∏è

#### **1. Docker & Kubernetes**
```bash
# Docker Compose for local development
docker-compose up -d

# Kubernetes for production
kubectl apply -f deployment.yaml
kubectl scale deployment my-app --replicas=10
```

#### **2. Service Mesh (Istio/Linkerd)**
- Traffic management
- Security (mTLS)
- Observability

#### **3. Monitoring Stack**
- **Prometheus:** Metrics collection
- **Grafana:** Visualization
- **Jaeger:** Distributed tracing

---

## üèóÔ∏è **Object-Oriented Programming (OOP) Deep Dive**

### **Essential OOP LeetCode Problems:**
- [ ] **Design LRU Cache (LC 146)** - HashMap + Doubly Linked List
- [ ] **Design HashMap (LC 706)** - Hash table implementation
- [ ] **Design Twitter (LC 355)** - Object-oriented design
- [ ] **Design Snake Game (LC 353)** - Game state management
- [ ] **Design Tic-Tac-Toe (LC 348)** - Game logic and validation
- [ ] **Design File System (LC 588)** - Tree structure with operations
- [ ] **Design Search Autocomplete (LC 642)** - Trie + ranking
- [ ] **Design Browser History (LC 1472)** - Stack/navigation
- [ ] **Design Underground System (LC 1396)** - Data tracking
- [ ] **Design Parking System (LC 1603)** - Resource management

### **SOLID Principles Practice:**
- [ ] **Single Responsibility:** Each class has one job
- [ ] **Open/Closed:** Open for extension, closed for modification
- [ ] **Liskov Substitution:** Subclasses should be substitutable
- [ ] **Interface Segregation:** Many specific interfaces > one general
- [ ] **Dependency Inversion:** Depend on abstractions, not concretions

### **Design Patterns to Master:**
- [ ] **Singleton:** Database connections, logging
- [ ] **Factory:** Object creation based on input
- [ ] **Observer:** Event handling, notifications
- [ ] **Strategy:** Algorithm selection at runtime
- [ ] **Decorator:** Adding functionality dynamically
- [ ] **Command:** Encapsulating operations
- [ ] **Builder:** Complex object construction

---

## üìÅ **Portfolio Showcase Strategy**

### **GitHub Portfolio Structure** üìÇ
```
your-github-username/
‚îú‚îÄ‚îÄ ai-personal-assistant/          # RAG Project
‚îÇ   ‚îú‚îÄ‚îÄ README.md (detailed)
‚îÇ   ‚îú‚îÄ‚îÄ demo.gif
‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îî‚îÄ‚îÄ docker-compose.yml
‚îú‚îÄ‚îÄ computer-vision-classifier/     # CV Project
‚îú‚îÄ‚îÄ recommendation-system/          # RecSys Project
‚îú‚îÄ‚îÄ nlp-pipeline/                  # NLP Project
‚îú‚îÄ‚îÄ mlops-platform/                # MLOps Project
‚îú‚îÄ‚îÄ generative-ai-app/             # GenAI Project
‚îú‚îÄ‚îÄ algorithm-solutions/           # LeetCode solutions
‚îÇ   ‚îú‚îÄ‚îÄ arrays/
‚îÇ   ‚îú‚îÄ‚îÄ trees/
‚îÇ   ‚îú‚îÄ‚îÄ dynamic-programming/
‚îÇ   ‚îî‚îÄ‚îÄ system-design/
‚îî‚îÄ‚îÄ README.md (main profile)
```

### **Resume Projects Section** üìÑ
```
PROJECTS

Personal AI Assistant with RAG | Python, LangChain, OpenAI API         2024
‚Ä¢ Built end-to-end RAG system processing 1000+ documents with 95% relevance
‚Ä¢ Implemented vector similarity search using Pinecone, reducing query time by 60%
‚Ä¢ Deployed scalable web app serving 500+ users with Streamlit and Docker

Real-time Recommendation System | Python, Kafka, Redis                  2024
‚Ä¢ Designed collaborative filtering system achieving 40% click-through rate
‚Ä¢ Built streaming pipeline processing 100K+ events/day with Apache Kafka
‚Ä¢ Implemented A/B testing framework improving model performance by 15%

Computer Vision Classifier | PyTorch, OpenCV, FastAPI                  2024
‚Ä¢ Trained custom CNN achieving 98% accuracy on 10K+ image dataset
‚Ä¢ Built REST API handling 1000+ requests/minute with <50ms response time
‚Ä¢ Deployed production system using Docker and AWS ECS
```

---

## üéØ **Interview Preparation Integration**

### **Technical Deep Dives** üîç
For each project, prepare to discuss:
- [ ] **Architecture decisions:** Why this tech stack?
- [ ] **Scalability challenges:** How to handle 10x traffic?
- [ ] **Performance optimization:** Bottlenecks and solutions
- [ ] **Trade-offs:** Alternative approaches considered
- [ ] **Monitoring & debugging:** How to troubleshoot issues

### **Behavioral Stories from Projects** üìñ
1. **Leadership:** "When I led the MLOps platform project..."
2. **Problem Solving:** "During the recommendation system development..."
3. **Innovation:** "I introduced a novel approach to..."
4. **Collaboration:** "Working with the frontend team on..."
5. **Learning:** "When I encountered this ML challenge..."

### **Code Review Practice** üëÄ
Be ready to:
- [ ] Walk through your code architecture
- [ ] Explain design patterns used
- [ ] Discuss testing strategies
- [ ] Demonstrate debugging skills
- [ ] Show performance optimizations

### **AI/ML Specific Interview Topics** ü§ñ
- [ ] **Model Selection:** Why choose this algorithm?
- [ ] **Data Pipeline:** How to handle data quality issues?
- [ ] **Feature Engineering:** Domain expertise and creativity
- [ ] **Model Evaluation:** Metrics selection and interpretation
- [ ] **Production Challenges:** Monitoring model drift
- [ ] **Ethical AI:** Bias detection and mitigation

---

## üéØ **Top 20 Algorithm Patterns (Must Master)**

1. **Two Pointers**
   - [ ] Two Sum II (LC 167)
   - [ ] 3Sum (LC 15)
   - [ ] Container With Most Water (LC 11)

2. **Sliding Window**
   - [ ] Longest Substring Without Repeating Characters (LC 3)
   - [ ] Minimum Window Substring (LC 76)
   - [ ] Sliding Window Maximum (LC 239)

3. **Fast & Slow Pointers**
   - [ ] Linked List Cycle (LC 141)
   - [ ] Find the Duplicate Number (LC 287)
   - [ ] Happy Number (LC 202)

4. **Merge Intervals**
   - [ ] Merge Intervals (LC 56)
   - [ ] Insert Interval (LC 57)
   - [ ] Meeting Rooms II (LC 253)

5. **Cyclic Sort**
   - [ ] Missing Number (LC 268)
   - [ ] Find All Numbers Disappeared in Array (LC 448)
   - [ ] Find the Duplicate Number (LC 287)

6. **In-place Reversal of LinkedList**
   - [ ] Reverse Linked List (LC 206)
   - [ ] Reverse Nodes in k-Group (LC 25)
   - [ ] Reverse Linked List II (LC 92)

7. **Tree BFS**
   - [ ] Binary Tree Level Order Traversal (LC 102)
   - [ ] Binary Tree Zigzag Level Order Traversal (LC 103)
   - [ ] Minimum Depth of Binary Tree (LC 111)

8. **Tree DFS**
   - [ ] Path Sum (LC 112)
   - [ ] All Paths for a Sum (LC 113)
   - [ ] Count Paths for a Sum (LC 437)

9. **Two Heaps**
   - [ ] Find Median from Data Stream (LC 295)
   - [ ] Sliding Window Median (LC 480)
   - [ ] IPO (LC 502)

10. **Subsets**
    - [ ] Subsets (LC 78)
    - [ ] Subsets II (LC 90)
    - [ ] Permutations (LC 46)

11. **Modified Binary Search**
    - [ ] Binary Search (LC 704)
    - [ ] Search in Rotated Sorted Array (LC 33)
    - [ ] Find Minimum in Rotated Sorted Array (LC 153)

12. **Top K Elements**
    - [ ] Kth Largest Element in Array (LC 215)
    - [ ] Top K Frequent Elements (LC 347)
    - [ ] Kth Smallest Element in BST (LC 230)

13. **K-way Merge**
    - [ ] Merge k Sorted Lists (LC 23)
    - [ ] Kth Smallest Element in Sorted Matrix (LC 378)
    - [ ] Smallest Range Covering Elements from K Lists (LC 632)

14. **Dynamic Programming**
    - [ ] 0/1 Knapsack Pattern
    - [ ] Unbounded Knapsack Pattern
    - [ ] Fibonacci Numbers Pattern
    - [ ] Palindromic Subsequence Pattern
    - [ ] Longest Common Substring Pattern

15. **Topological Sort**
    - [ ] Course Schedule (LC 207)
    - [ ] Course Schedule II (LC 210)
    - [ ] Alien Dictionary (LC 269)

16. **Backtracking**
    - [ ] Letter Combinations of Phone Number (LC 17)
    - [ ] Generate Parentheses (LC 22)
    - [ ] N-Queens (LC 51)
    - [ ] Word Search (LC 79)

17. **Union Find**
    - [ ] Number of Connected Components (LC 323)
    - [ ] Graph Valid Tree (LC 261)
    - [ ] Redundant Connection (LC 684)

18. **Greedy**
    - [ ] Jump Game (LC 55)
    - [ ] Gas Station (LC 134)
    - [ ] Minimum Number of Arrows to Burst Balloons (LC 452)

19. **Bit Manipulation**
    - [ ] Single Number (LC 136)
    - [ ] Number of 1 Bits (LC 191)
    - [ ] Power of Two (LC 231)

20. **Math & Geometry**
    - [ ] Rotate Image (LC 48)
    - [ ] Spiral Matrix (LC 54)
    - [ ] Set Matrix Zeroes (LC 73)

---

## üõ†Ô∏è Resources & Tools

### üìö H·ªçc T·∫≠p
- **Books:**
  - "Cracking the Coding Interview" - Gayle McDowell
  - "System Design Interview" - Alex Xu
  - "Designing Data-Intensive Applications" - Martin Kleppmann

- **Online Platforms:**
  - LeetCode Premium
  - System Design Primer (GitHub)
  - InterviewBit
  - Pramp (mock interviews)

### üîß Practice Tools
- **Coding:**
  - LeetCode
  - HackerRank
  - CodeSignal

- **System Design:**
  - Draw.io (diagrams)
  - Lucidchart
  - Excalidraw

### üì± Apps
- **Anki:** Spaced repetition for algorithms
- **Notion:** Track progress
- **Calendly:** Schedule mock interviews

---

## üìà Progress Tracking

### Monthly Milestones
- **Month 1:** Solve 100 easy problems
- **Month 2:** Solve 80 medium problems  
- **Month 3:** Solve 20 hard problems
- **Month 4:** Complete 5 system design cases
- **Month 5:** Complete 10 system design cases
- **Month 6:** Start mock interviews

### Key Metrics
- [ ] **Problems Solved:** Target 300+ problems
- [ ] **System Design Cases:** Target 15+ complete designs
- [ ] **Mock Interviews:** Target 20+ sessions
- [ ] **Behavioral Stories:** Prepare 10+ STAR stories

---

## üéØ Company Application Timeline

### Target Companies (in order of difficulty)
1. **Warm-up Companies:** Smaller tech companies
2. **Mid-tier:** Uber, Airbnb, Spotify
3. **FAANG:** Apply when confident (Month 10+)

### Application Strategy
- [ ] **Network First:** Try to get referrals
- [ ] **Multiple Applications:** Apply to 3-5 companies simultaneously
- [ ] **Schedule Wisely:** Start with easier companies

---

## üö® Common Pitfalls to Avoid

1. **Rushing through fundamentals**
2. **Focusing only on coding, ignoring system design**
3. **Not practicing behavioral questions**
4. **Applying too early without proper preparation**
5. **Burning out with excessive practice**

---

## üí™ Success Tips

1. **Consistency > Intensity:** Better to study 2 hours daily than 14 hours on weekends
2. **Quality > Quantity:** Understand solutions deeply
3. **Practice Speaking:** Explain your thought process aloud
4. **Stay Updated:** Follow tech blogs and industry news
5. **Take Breaks:** Prevent burnout with regular rest

---

## üìû Emergency Plan
N·∫øu c√≥ opportunity interview b·∫•t ng·ªù:
- [ ] **2 weeks:** Focus on most common problems
- [ ] **1 week:** Behavioral prep + system design basics
- [ ] **3 days:** Company-specific preparation
- [ ] **1 day:** Rest and mental preparation

---

## üö® **Last-Minute Prep (1-2 weeks)**

### **Week 1: Algorithm Cramming**
#### Day 1-2: Array & String Patterns
- [ ] Two Sum variants (LC 1, 167, 170)
- [ ] Sliding Window (LC 3, 76, 209, 424)
- [ ] Two Pointers (LC 11, 15, 42)

#### Day 3-4: Linked List & Trees
- [ ] Linked List (LC 206, 141, 21, 23, 143)
- [ ] Tree Traversal (LC 104, 102, 94, 144, 145)
- [ ] BST (LC 98, 230, 235)

#### Day 5-6: Dynamic Programming
- [ ] 1D DP (LC 70, 198, 322, 300)
- [ ] 2D DP (LC 62, 63, 72, 1143)

#### Day 7: Mixed Review
- [ ] Graph BFS/DFS (LC 200, 133, 207)
- [ ] Backtracking (LC 46, 78, 79)

### **Week 2: System Design + Behavioral**
#### Day 1-3: Core System Design
- [ ] **Scalability basics:** Load balancing, caching, sharding
- [ ] **Database choice:** SQL vs NoSQL scenarios
- [ ] **Practice 3 designs:** URL shortener, Chat system, Social feed

#### Day 4-5: Behavioral Prep
- [ ] **STAR Stories:** Prepare 5 core stories
  - Leadership example
  - Conflict resolution
  - Technical challenge
  - Failure/learning
  - Innovation/improvement

#### Day 6-7: Company-Specific
- [ ] **Google:** Focus on scale, algorithms
- [ ] **Meta:** DP problems, cultural fit
- [ ] **Amazon:** Leadership principles
- [ ] **Apple:** System programming, iOS
- [ ] **Netflix:** Distributed systems

---

## üéØ **Top 50 Must-Solve Problems (Emergency List)**

### **Arrays & Strings (12 problems)**
1. [ ] Two Sum (LC 1) ‚≠ê
2. [ ] Best Time to Buy and Sell Stock (LC 121) ‚≠ê
3. [ ] Contains Duplicate (LC 217) ‚≠ê
4. [ ] Product of Array Except Self (LC 238) ‚≠ê
5. [ ] Maximum Subarray (LC 53) ‚≠ê
6. [ ] 3Sum (LC 15) ‚≠ê‚≠ê
7. [ ] Container With Most Water (LC 11) ‚≠ê‚≠ê
8. [ ] Longest Substring Without Repeating Characters (LC 3) ‚≠ê‚≠ê
9. [ ] Group Anagrams (LC 49) ‚≠ê‚≠ê
10. [ ] Valid Parentheses (LC 20) ‚≠ê
11. [ ] Longest Palindromic Substring (LC 5) ‚≠ê‚≠ê
12. [ ] Trapping Rain Water (LC 42) ‚≠ê‚≠ê‚≠ê

### **Linked Lists (6 problems)**
13. [ ] Reverse Linked List (LC 206) ‚≠ê
14. [ ] Linked List Cycle (LC 141) ‚≠ê
15. [ ] Merge Two Sorted Lists (LC 21) ‚≠ê
16. [ ] Remove Nth Node From End (LC 19) ‚≠ê‚≠ê
17. [ ] Reorder List (LC 143) ‚≠ê‚≠ê
18. [ ] Merge k Sorted Lists (LC 23) ‚≠ê‚≠ê‚≠ê

### **Trees (8 problems)**
19. [ ] Maximum Depth of Binary Tree (LC 104) ‚≠ê
20. [ ] Same Tree (LC 100) ‚≠ê
21. [ ] Invert Binary Tree (LC 226) ‚≠ê
22. [ ] Binary Tree Level Order Traversal (LC 102) ‚≠ê‚≠ê
23. [ ] Subtree of Another Tree (LC 572) ‚≠ê
24. [ ] Lowest Common Ancestor of BST (LC 235) ‚≠ê‚≠ê
25. [ ] Validate Binary Search Tree (LC 98) ‚≠ê‚≠ê
26. [ ] Kth Smallest Element in BST (LC 230) ‚≠ê‚≠ê

### **Graphs (6 problems)**
27. [ ] Number of Islands (LC 200) ‚≠ê‚≠ê
28. [ ] Clone Graph (LC 133) ‚≠ê‚≠ê
29. [ ] Course Schedule (LC 207) ‚≠ê‚≠ê
30. [ ] Pacific Atlantic Water Flow (LC 417) ‚≠ê‚≠ê
31. [ ] Number of Connected Components (LC 323) ‚≠ê‚≠ê
32. [ ] Word Ladder (LC 127) ‚≠ê‚≠ê‚≠ê

### **Dynamic Programming (8 problems)**
33. [ ] Climbing Stairs (LC 70) ‚≠ê
34. [ ] House Robber (LC 198) ‚≠ê‚≠ê
35. [ ] Coin Change (LC 322) ‚≠ê‚≠ê
36. [ ] Longest Increasing Subsequence (LC 300) ‚≠ê‚≠ê
37. [ ] Word Break (LC 139) ‚≠ê‚≠ê
38. [ ] Combination Sum IV (LC 377) ‚≠ê‚≠ê
39. [ ] Longest Common Subsequence (LC 1143) ‚≠ê‚≠ê
40. [ ] Edit Distance (LC 72) ‚≠ê‚≠ê‚≠ê

### **Intervals & Greedy (5 problems)**
41. [ ] Merge Intervals (LC 56) ‚≠ê‚≠ê
42. [ ] Insert Interval (LC 57) ‚≠ê‚≠ê
43. [ ] Non-overlapping Intervals (LC 435) ‚≠ê‚≠ê
44. [ ] Meeting Rooms (LC 252) ‚≠ê
45. [ ] Meeting Rooms II (LC 253) ‚≠ê‚≠ê

### **Advanced (5 problems)**
46. [ ] Find Median from Data Stream (LC 295) ‚≠ê‚≠ê‚≠ê
47. [ ] Serialize and Deserialize Binary Tree (LC 297) ‚≠ê‚≠ê‚≠ê
48. [ ] Design Add and Search Words Data Structure (LC 211) ‚≠ê‚≠ê
49. [ ] Implement Trie (LC 208) ‚≠ê‚≠ê
50. [ ] Word Search II (LC 212) ‚≠ê‚≠ê‚≠ê

## üìÅ **Portfolio Showcase Strategy**

### **GitHub Portfolio Structure** üìÇ
```
your-github-username/
‚îú‚îÄ‚îÄ ai-personal-assistant/          # RAG Project
‚îÇ   ‚îú‚îÄ‚îÄ README.md (detailed)
‚îÇ   ‚îú‚îÄ‚îÄ demo.gif
‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îî‚îÄ‚îÄ docker-compose.yml
‚îú‚îÄ‚îÄ computer-vision-classifier/     # CV Project
‚îú‚îÄ‚îÄ recommendation-system/          # RecSys Project
‚îú‚îÄ‚îÄ nlp-pipeline/                  # NLP Project
‚îú‚îÄ‚îÄ mlops-platform/                # MLOps Project
‚îú‚îÄ‚îÄ generative-ai-app/             # GenAI Project
‚îú‚îÄ‚îÄ algorithm-solutions/           # LeetCode solutions
‚îÇ   ‚îú‚îÄ‚îÄ arrays/
‚îÇ   ‚îú‚îÄ‚îÄ trees/
‚îÇ   ‚îú‚îÄ‚îÄ dynamic-programming/
‚îÇ   ‚îî‚îÄ‚îÄ system-design/
‚îî‚îÄ‚îÄ README.md (main profile)
```

### **Project Documentation Template** üìù
```markdown
# Project Title

## üéØ Problem Statement
[Describe the real-world problem you're solving]

## üèóÔ∏è Architecture
[System architecture diagram]

## üõ†Ô∏è Tech Stack
- **Backend:** Python, FastAPI, PostgreSQL
- **ML/AI:** PyTorch, transformers, scikit-learn
- **Infrastructure:** Docker, AWS/GCP, Kubernetes
- **Monitoring:** MLflow, Prometheus, Grafana

## üìä Results
- **Performance:** 95% accuracy, <100ms latency
- **Scale:** Handles 10K+ requests/second
- **Impact:** Improved user engagement by 25%

## üöÄ Live Demo
[Link to deployed application]

## üìπ Video Walkthrough
[3-5 minute demo video]

## üîç Key Learnings
[Technical challenges and solutions]
```

### **Resume Projects Section** üìÑ
```
PROJECTS

Personal AI Assistant with RAG | Python, LangChain, OpenAI API         2024
‚Ä¢ Built end-to-end RAG system processing 1000+ documents with 95% relevance
‚Ä¢ Implemented vector similarity search using Pinecone, reducing query time by 60%
‚Ä¢ Deployed scalable web app serving 500+ users with Streamlit and Docker

Real-time Recommendation System | Python, Kafka, Redis                  2024
‚Ä¢ Designed collaborative filtering system achieving 40% click-through rate
‚Ä¢ Built streaming pipeline processing 100K+ events/day with Apache Kafka
‚Ä¢ Implemented A/B testing framework improving model performance by 15%

Computer Vision Classifier | PyTorch, OpenCV, FastAPI                  2024
‚Ä¢ Trained custom CNN achieving 98% accuracy on 10K+ image dataset
‚Ä¢ Built REST API handling 1000+ requests/minute with <50ms response time
‚Ä¢ Deployed production system using Docker and AWS ECS
```

---

## üéØ **Interview Preparation Integration**

### **Technical Deep Dives** üîç
For each project, prepare to discuss:
- [ ] **Architecture decisions:** Why this tech stack?
- [ ] **Scalability challenges:** How to handle 10x traffic?
- [ ] **Performance optimization:** Bottlenecks and solutions
- [ ] **Trade-offs:** Alternative approaches considered
- [ ] **Monitoring & debugging:** How to troubleshoot issues

### **Behavioral Stories from Projects** üìñ
1. **Leadership:** "When I led the MLOps platform project..."
2. **Problem Solving:** "During the recommendation system development..."
3. **Innovation:** "I introduced a novel approach to..."
4. **Collaboration:** "Working with the frontend team on..."
5. **Learning:** "When I encountered this ML challenge..."

### **Code Review Practice** üëÄ
Be ready to:
- [ ] Walk through your code architecture
- [ ] Explain design patterns used
- [ ] Discuss testing strategies
- [ ] Demonstrate debugging skills
- [ ] Show performance optimizations

---

## üí™ **Communication Skills Practice**

### **Code Narration Template**
```
1. "Let me understand the problem..."
2. "I'll think about the approach..."
3. "Let me trace through an example..."
4. "I'll implement this step by step..."
5. "Let me test this with edge cases..."
6. "The time complexity is... because..."
7. "The space complexity is... because..."
```

### **System Design Presentation Skills**
- [ ] **Start with clarification:** "Let me make sure I understand..."
- [ ] **Think out loud:** "I'm considering these options..."
- [ ] **Draw as you speak:** Visual + verbal explanation
- [ ] **Discuss trade-offs:** "The benefit of this approach is... but the downside is..."
- [ ] **Handle uncertainty:** "I'm not sure about this part, but I would investigate..."

### **Behavioral Interview Framework (STAR)**
```
Situation: Set the context (When? Where? Who?)
Task: Describe your responsibility (What needed to be done?)
Action: Explain what you did (How did you approach it?)
Result: Share the outcome (What was the impact?)
```

#### Example Stories to Prepare
1. **Technical Leadership**
   - Led architecture decision
   - Mentored junior developer
   - Drove technical initiative

2. **Problem Solving**
   - Debugged complex issue
   - Optimized performance
   - Resolved production incident

3. **Collaboration**
   - Worked with difficult teammate
   - Cross-functional project
   - Influenced without authority

4. **Innovation**
   - Improved existing process
   - Introduced new technology
   - Creative solution

5. **Learning & Growth**
   - Failed project and lessons learned
   - Adapted to new technology
   - Overcame technical challenge

---

**Ch√∫c b·∫°n th√†nh c√¥ng! üöÄ**

> "Success is where preparation and opportunity meet." - Bobby Unser